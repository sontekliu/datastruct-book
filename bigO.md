# 简单的时间复杂度分析

在算法和数据结构领域，使用复杂度分析的方式来检测代码的性能。时间复杂度分析本身是一个相对理论化的领域
，如果真要研究它的话，里面涉及大量数学的内容和一些新的概念，本文只是相对简单的说一下时间复杂度是怎么
一回事，有个相对感性的认识即可，大体了解并能做简单分析即可。

时间复杂度到底是怎么一回事?

同常我们会说一个算法的时间复杂度是 O(1), O(n), O(logn), O(nlogn), O(n^2) 等。
简单的来说大 O 描述的是算法的运行时间和输入数据之间的关系。看如下代码:

```
public static int sum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    return sum;
}
```

该代码的时间复杂度是 `O(n)` 的，指的是该代码运行时间的多少和 `n` 的大小成线性关系的(其中 `n` 是数组元素的个数)，既然是线性关系，那为什么要用大O，叫做 O(n) 呢？

实际上是我们忽略了很多常数，实际上线性关系是: y = a * x + b (a, b均是常数)
在上面的 for 循环的代码中，我们首先要将数组中的数据取出来，其次是把 sum 的值取出来，再把 sum 和 num
的值加在一起，再把相加的结果赋值给 sum。针对数组中的每个元素都要进行如上操作，如上操作也就是线性方程
中的 a。在 for 循环开始前，还要为 sum 开辟内存空间，并将 0 赋值给 sum，等 for 循环结束之后，还要将结果返回，这些步骤可以理解为线性方程中的 b 。

我们在实际算法分析时，如果也把 a 和 b 的时间也分析出来，一方面是必要性不大的，另一方面是有时也是不可
能的，因为编译器不一样，生成的指令也不一样，CPU 的架构不一样，所执行指令的时间也不一样，所以很难分析
出具体的时间是多少。所以在时间分析算法的时间复杂度时，我们时忽略掉常数的，忽略常数也就意味着，如下：

| 线性方程                   | 时间复杂度 |
|----------------------------|------------|
| T = 2 * n + 2              | O(n)       |
| T = 2000 * n + 10000       | O(n)       |
| T = 1 * n * n + 0          | O(n^2)     |
| T = 2 * n * n + 200 * n + 10 | O(n^2)     |

如上表格，第一个和第二个虽然常数值差距很大，但是其时间复杂度是一样的。第二个和第三个的常数差距也比较
大，但是其时间复杂度却是 O(n^2) 的，也就是说第三个的性能是比前两个性能低。但是我们可能有疑问了，如果
n = 10 的话，第二个消耗的时间是 30000，而第三个消耗的时间是 100，明显第三个快，事实也是如此。

如果一个算法是 O(n) ，另一个算法是 O(n^2) 并不是说对应任意输入来说 O(n) 一定要快于 O(n^2) ,具体的确
实需要看常数的值。但是大O其实是表示的一种`渐进时间复杂度`，也就是描述的当 n 趋近于无穷的时候，两个算
法谁快谁慢，例如第四个线性关系表达式，当 n 趋近于无穷的时候，低阶项的影响可以忽略不计了，所以时间复
杂度也是 O(n^2)

在实际的开发中，在 n 较小的情况下，很多高阶算法因为常数比较小，可能会快于低阶算法。

综上所述，大O描述的是一个算法的渐进时间复杂度。也就是说该算法消耗的时间和输入数据规模之间的关系。


---

数组的时间复杂度 

添加操作：

| 操作          | 时间复杂度    | 备注                                            |
|---------------|---------------|-------------------------------------------------|
| addLast(e)    | O(1)          | 表示和数组大小无关                              |
| addFirst(e)   | O(n)          | 涉及数据的移动                                  |
| add(index, e) | O(n/2) = O(n) | index 取值是0~size,且取值概率相等，求其期望即可 |

整体添加操作是 O(n) 通常关注最糟糕的情况，通常在现实生活中也是如此，如上班需要 5 分钟，考试蒙的方式

大多数情况下，考虑最好的情况，一般意义不大。

删除操作
| 操作             | 时间复杂度    | 备注 |
|------------------|---------------|------|
| removeLast(e)    | O(1)          | aaa  |
| removeFirst(e)   | O(n)          | bbb  |
| remove(index, e) | O(n/2) = O(n) | ccc     |


修改操作 
set(index, e) O(1) 这也是数组的优势

查找操作

get(index)  O(1)
contains(e) O(n)
indexOf(e) O(n)


增 : O(n)
删 : O(n)
改 : 已知索引O(1);未知索引O(n)
查 : 已知索引O(1);未知索引O(n)

使用数组，尽量让其索引含有一定的语义, 这样就能很好提高数组的性能



